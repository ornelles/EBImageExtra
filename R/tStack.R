#' Transpose an Array of Images
#'
#' Transpose the final dimension of a 3- or 4-dimensional array (stack)
#'
#' @param x array of 3- or 4-dimensions \code{Image}
#'   objects
#' @param n the number of adjacent images
#'
#' @details
#' This function will "transpose" an
#' \code{Image} object with 3 or 4 dimensions. The motivation behind this
#' function is to simplify the task of reordering an array generated by
#' sequentially combining several image groups so that related images are
#' adjacent.
#'
#' In a typical example, three different images (DAPI, FITC, and Cy3) are
#' taken of many separate fields of cells. The images are
#' separated, colorized, and then combined with \code{combine(...)} or
#' \code{abind(..., along = 4)}. Plotting as \code{plot(..., all= TRUE)}
#' shows the images arranged sequentially with all DAPI first, then FITC
#' and then Cy5. "Transposing" this image orders related fields together.
#'
#' @return array of \code{Image} objects with the final dimension permuted
#'
#' @examples
#' # Example of DAPI/Rhodamine pairs
#'   x <- readImage(system.file("inst", "extdata", "cells.tif", package="EBImageExtra"))
#'   nuc <- x[,,c(1,3)]
#'   cel <- x[,,c(2,4)]
#'   img <- rgbImage(red = cel, green = 0.1 * cel + 0.2 * nuc, blue = 0.4 * nuc)
#'   stk <- combine(rgbImage(green = 0.2 * nuc, blue = 0.4 * nuc),
#'     rgbImage(red = cel, green = 0.1 * cel), img)
#' 
#' # Original order
#'   plotStack(stk, label = TRUE, nx = 3)
#' 
#' # "Transposed" order
#'   plotStack(tStack(stk, n = 3), label = TRUE, nx = 3)
#' 
#' @import EBImage
#'
#' @export
#'
tStack <- function(x, n) {
	if (missing(n))
		stop("provide the number of adjacent frames to be separated")
  dm <- dim(x)
  if (colorMode(x) == 0 && length(dm) == 2)
    ans <- x
  else if (colorMode(x) == 2 && length(dm) == 3)
    ans <- x
  else {
    nf <- dm[length(dm)]
    nx <- nf%/%n
    N <- seq.int(n * nx)
    if (max(N) != nf) warning("the last ", nf - max(N), " frame(s) were dropped")
    idx <- lapply(dm, seq.int) # expanded image coordinates
    idx[[length(idx)]] <- c(matrix(N, ncol = nx, byrow = TRUE))
    ans <- do.call("[", c(list(x), idx)) # replace dimension
  }
  return(ans)
}
