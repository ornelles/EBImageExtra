#' Transpose an Array of Images
#'
#' Transpose the final dimension of a 3- or 4-dimensional array (stack)
#'
#' @param stk array of 3- or 4-dimensions \code{Image}
#'   objects
#' @param n the number of adjacent images (default of 2)
#'
#' @details
#' This function will "transpose" an
#' \code{Image} object with 3 or 4 dimensions. The motivation behind this
#' function is simplify the task of reordering an array generated by
#' sequentially combining several image groups so that related images are
#' adjacent.
#'
#' As a typical example, three different images (DAPI, FITC, and Cy3) are
#' taken of four separate fields of cells for 12 images. The images are
#' separated, colorized, and then combined with \code{combine(...)} or
#' code{abind(..., along=4)}. Plotting as \code{plot(..., all= TRUE, nx =
#' 4)} shows the same field arranged vertically. Transposing this image
#' allows it to be presented horizontally.
#'
#' @return array of \code{Image} objects with the final dimension permuted
#'
#' @import EBImage
#'
#' @export
#'
tStack <- function(x, n = 2) {
	dm <- dim(x)
	if (colorMode(x) == 0 && length(dm) == 2)
		ans <- x
	else if (colorMode(x) == 2 && length(dm) == 3)
		ans <- x
	else {
		nf <- dm[length(dm)]
		nx <- nf%/%n
		N <- seq.int(n * nx)
		if (max(N) != nf) warning("the last ", nf - max(N), " frame(s) were dropped")
		idx <- lapply(dm, seq.int) # expanded image coordinates
		idx[[length(idx)]] <- c(matrix(N, ncol = nx, byrow = TRUE))
		ans <- do.call("[", c(list(x), idx)) # replace dimension
	}
	return(ans)
}
